Bear With Me for a Sec
===

Sets
===

A set is a collection of things... Because set theory is, like Category theory, abstract, the things can be anything you want. Consider, for example these balls: 

![Balls](elements.svg)
For example let's construct a set, call it A, consisting of *all* of them. This is how we can mark it:

![The set of all balls](all.svg)

This may look childish at first, but this set is just as valid as the sets of all natural numbers.

The key difference between a given set of items and the items themselves is that the set summarizes the things which it contains i.e. enables you to reason about several things as if they were one.
 
Subsets
---

Let's construct one more set. The set of *all balls that are warm color*. Again I will give it a name - W:

![W - the set of all balls of warm colors](subset.svg)

Notice that W contains just elements that are also present in A. That is, every element of the set of W is also an element in the set A. When two sets have this relation exists, we may say that W is a *subset* of A, and draw a graphic like this one:

![W and A together](set_subset.svg)

\[ W \subset A \]

Singleton Sets
---

The set of all *red balls* contains just one ball:

![The singleton set of red balls](singleton.svg)

You may find it contradictory that we say that sets are just for summarizing several elements into one, but we still have sets that contain just one element. Actually is perfectly useful. If I ask you to make a set of all books that you are reading right now, you shouldn't have trouble doing it just because you are reading just this one book currently.

The Empty set
---

Of course if 1 is a valid answer, so can be zero. If we want a set of all *black balls*  B or all the *white balls*, W, the answer to all these questions is the same - the empty set.

![The empty set](void.svg)


Note that two sets that contain the same elements are equivalent, which means that, there is no difference between the set that contains zero *balls*, and the set that contains zero *numbers*, for instance. 


In other words, the empty set is unique set, which makes it a very special one.
\[ B = W = \varnothing \]

For example, it is a subset of every other set. 

\[ \forall A  A \subset \varnothing \]

We will encounter the empty set again.

Functions
===

A function is a relationship between two sets which matches each element of one set, called the *domain* of the function, with exactly one element from another set, called the converse domain, or the *codomain*. 

Here is a function, *f* which maps each ball from the set *A* to its opposite color:
![Opposite colors](function_one_one.svg)

\[ f: A -> A \]

This is probably the simplest type of function there exists. Firstly because its domain and codomain are the same set, and secondly, because it expresses a so called one-to-one relationship, which means each element from one set is connected to just one other element from the other set.

But a functions are much more powerful than that. They can also express many-to-one relationships. In other words, there can be many elements from the domain of the function, which relate to the same element from the codomain (but not the other way around).

The domain can be bigger than the codomain in which case several elements from the domain will be mapped to the same element from the codomain:
![Function from a bigger set to a smaller one](function_big_small.svg)

The domain can be smaller than the codomain in which case some elements from the codomain will not play a part.
![Function from a bigger set to a smaller one](function_small_big.svg)

However you cannot have a domain element which is not mapped to anything, or which is mapped to more than one element. In other words (and this is also the reason that functions are the way they are) if you give a function an element of its domain, it should always be able to give you back exactly one element of its codomain. 

Question: Do these functions and sets *express* something? Should a function express something in order to be valid? 

The Identity Function
---

For each set *G*, no matter what it represents, we can define the function that does nothing, called the identity function for s or *idG* - a function in which the set is both domain and codomain, and each element is mapped to itself:

![The identity function](function_identity.svg)

You can think of **idS** as a function which represents the set in the realm of functions. It's existence allows us to prove many theorems that we "know" by intuition, formally.

Functions and Subsets
---
For each set and subset, no matter what they represent, we can define the function that maps each element of the subset to itself:
![A function from subset to set](subset-set.svg)

Sets, Functions and Numerical Operation
===

All mathematical operations can be expressed as functions, acting on the set of all numbers. Actually there are several such sets, such the set of positive whole numbers, (also called "natural" numbers), which is called `N`: {1, 2, 3... InfinityTODO}, the set of both positive and negative whole numbers (called `Z` for some reason) and so on.

For example, squaring a number is a function - its domain is the set of all numbers and its codomain is the set of all positive numbers (remember that the square of a number is always positive). Because both sets are infinite, we cannot draw the whole function, however we can draw a part of it: 

![The square function](square.svg)


All numbers from the codomain will have two arrows pointing at them (one for the positive square root and one for the negative one), and that is OK. 

Zero from the domain will be connected to the zero from the codomain, so to itself, and this is OK.

Some numbers aren't the square of any other number. That is also OK.

Overall everything is OK, as long as you can always provide exactly one result (also known as "The result") per value, and in mathematics almost always do. Actually most types of numbers were created so mathematical operations are valid functions:

> Every generalisation of number has ﬁrst presented itself as needed for some simple problem: negative numbers were needed in order that subtraction might be always possible, since otherwise a − b would be meaningless if a were less than b; fractions were needed in order that division might be always possible; and complex numbers are needed in order that extraction of roots and solution of equations may be always possible. 

Most mathematical operations, such as addition, multiplication etc. require two numbers in order to produce a result. Depending on what we need, we may present those operations as functions from the sets of *tuples* of numbers, to the set of numbers, or we may say that they take a number and return a function. More on that later.

Sets and Functions in Programming
===

Sets are used extensively in programming, except that there they are called *types* or also *classes*. All sets of number that we discussed earlier also exist as types, and there are also some non-mathematical types:

The simplest type, `Boolen` is nothing more than a set of two values - `true` and `false`:

![Set of boolean values](boolean.svg)

Another very basic set in programming is the set of keyboard characters, or `Char`: 

![Set of characters](char.svg)

Characters are actually used rarely by themselves and mostly as parts of sequences.

Most of the types of programming are composite types - they are a combination of the limited types that are listed here. Again, we will cover these later.

Question: What is the equivalent of subsets in programming?

Functions in programming resemble mathematical functions. A function that takes an argument of type `Char` and returns a `Boolean` is nothing more than a mapping between the two sets that we covered above:

![A function from Char to Boolean](char_boolean.svg)

However functions in programming can also be quite different from mathematical functions - they can perform various operations that have nothing to do with returning a value. These operations are called side effects. Most common programming languages and paradigms were created at a times when the computer resources were much more limited than today, and programming - much more cumberstone, so people had bigger problems than the fact that their functions were not mathematically sound. That is why they didn't have a way to handle side effects, or to differentiate functions that have side effects from the ones that don't. But that is another story.

Some more examples
===

Sets and functions can express relationships between all kinds of objects, and even people. Every question that you ask can possibly be expressed as a function.

The question "How far are we from New York?" is a function with a domain the set of places in the world and the set of positive numbers as its codomain.

The question "Who is my father?" is a function whose domain is the set of all people in the world and the same set as its codomain. 
Note that the question "Who is my child?" is *NOT* a function, because a person can have no children, or can have multiple children. We will learn to represent such questions as functions later.

Functional Composition 
===

Let's assume that we have two functions, **g** and **f** and the codomain of the first one is the same set as the domain of the second.

![Matching functions](functions_matching.svg)

Then we can apply the first function **g** to some set then apply the second function to the result of the first one (we can do that because each function produces exactly one result).

![Applying one function after another](functions_one_after_another.svg)


Lastly, we can define a new function, (lets call it **h**) that has the same effect as if we applied the above two functions in the manner described above. The resulting function is called the *composition* of the other two functions, and is denoted **f ∘ g** (notice that the first function is on the right, so its similar to **b = f(g(a)**).

![Functional composition](functions_compose.svg)

Composition is the essence of all things categorical. The key insight is that the result of composing two parts is no more complex than the parts themselves. 

Representing Composition with Commutative Diagrams
---

We may view the last diagram not as a definition of **h**, but as a statement that reads "**h** is equivalent to **f ∘ g**". The equivalence is expressed by the fact that if you follow the arrow **g** for any element of set **A** you will get to the same element of the set **C** as if you follow the **g** and then follow **f**. Diagrams that express equivalence of sequences of function application, such as this one, are called *commutative diagrams* or diagrams which commute.

![Functional composition](functions_compose.svg)


If we "zoom-out" the last diagram so it does not show the elements of the sets, we get a more general diagram for functional composition.

![Functional composition for sets](functions_compose_sets.svg)

In fact, if we note that the diagram commutes (or that all paths with the same paths, starting from each set element lead the same corresponding element from the resulting set), then ennumerating the elements becomes redundant. So we can, for example, redefine functional composition in the following way:

The composition of two functions **f** and **g** is a third function defined in such a way that this diagram commutes.

![Functional composition - general definition](functions_compose_general.svg)

You will see more definitions like this in the future.

Isomorphisms
===

Let's go back to the function that demonstrated a one-to-one relationship:

![Opposite colors](function_one_one.svg)

Notice that the function is invertible, that is if you flip its arrows you get another valid function:

![Opposite colors](isomorphism_one_one.svg)

Invertible functions are called isomorphisms. When there is an invertible function between two sets we can say that the sets are isomorphic. For example the temperature measured in Celcius, is isomorphic to the temperature, measured in Fahrenheit.

More formally, two sets are isomorphic if there exist functions **f: W -> B** and its reverse **g B -> W**, such that **f ∘ g = idB** and **g ∘ f = idW** (notice how the identity function comes in handy).

Isomorphism and equality
---

The concept of an isomorphism is strongly related to the concept of equality (that is why it is denoted with **≅**, which is almost the same as **=**). 

For example, the identity function is reversible so each set is isomorphic to itself.

![The identity function](isomorphism_identity.svg)

Intuitively if two sets of things are isomorphic, this means that having an element from one of them, allows you to easily obtain an element from the other.

For example if you have a function "is the husband of" the set of all married men, as a domain and the set of all married woman as codomain, and the corresponding function, "is the wife of", then we may say that the sets of married men and married woman (ignoring some exceptions) are isomorphic. That is not to say that you are the same person as your significant other, but rather that every relation between yourself or any other object is also a relation about with him and the same object.

For example my wive's father is my father-in-law.



Isomorphisms Between Singleton Sets
---

For any two singleton sets, we may define the only possible function, which is also an isomorphism. 

This means that all singleton sets are isomorphic.

Note that
