<h1 id="from-sets-to-categories">From Sets to Categories</h1>
<p>In this chapter we will continue with set theory and at the same time, we will start exploring categories.</p>
<h1 id="products">Products</h1>
<p>At several times, during the previous chapter, we needed a way to make a set that is a composite of other sets that we already have. For example when we discussed mathematical functions, we couldn&#39;t define <strong>+</strong> and <strong>-</strong> functions, because we only knew about functions that take one argument. When we talked about programming, we talked about the primitive types, <code>Char</code> and <code>Number</code>, and we mentioned that most of the types are composite types. So how do we deal with those?</p>
<p>The simplest composite, or a <em>product</em>, of the sets <strong>B</strong>, which contains <strong>b</strong>&#39;s and the set<strong>Y</strong>, which contains <strong>y</strong>&#39;s...</p>
<p><img src="product_parts.svg" alt="Product parts"></p>
<p>... is just the set of <em>pairs</em> of <strong>b</strong>&#39;s and <strong>y</strong>&#39;s.</p>
<p><img src="product.svg" alt="Product"></p>
<p>The product is denoted <strong>B x Y</strong> and it comes equipped with two functions for retrieving the <strong>b</strong> and the <strong>y</strong> from each <strong>(b, y)</strong>.</p>
<p>Question: Why is this called a product? Hint: How many elements does it have?</p>
<h2 id="products-as-objects">Products as Objects</h2>
<p>We established that in programming sets resemble types and functions resemble functions. Products, in this case, are like stripped-out <em>classes</em> (also called <em>records</em> or <em>structs</em>). The composite sets (the ones which form the product) are just the class&#39;s fields (also called <em>members</em>). The functions for accessing them are like what programmers call <em>getter methods</em>.</p>
<p>For example the famous OOP example of <code>Person</code> class with <code>name</code> and <code>age</code> fields is nothing more than a product of the set of strings, and the sets of numbers (we still haven&#39;t defined strings and lists in terms of set theory but we will get to that). Objects with more than two values can be expressed as products the composites of which are themselves products.</p>
<h2 id="using-products-to-define-numeric-operations">Using Products to Define Numeric Operations</h2>
<p>Products can also be used for expressing functions which take more than one argument. For example, &quot;plus&quot; and &quot;minus&quot;, are functions from set of the product of two numbers to the set of numbers. (so <strong>+: R x R → R</strong>). Of course, we cannot draw the function itself, even partly, because it has too much arrows and it would look messy.</p>
<p>Joking, here it is.</p>
<p><img src="plus.svg" alt="The plus function"></p>
<p>Note that there are languages where the <em>pair</em> datastructure (also called a <em>tuple</em>) is a first-level construct, and multi-argument functions are really implemented in this way. </p>
<h2 id="defining-products-in-terms-of-sets-">Defining products in Terms of Sets </h2>
<p>Now we will define the abstract concept of a product of two sets sets in terms of sets themselves. It is not hard: the product of two sets <strong>Y</strong> and <strong>B</strong> is just the set of all possible <em>ordered pairs</em>, which contain one element of the set <strong>Y</strong> and one element of the set <strong>B</strong>. Or formally speaking <strong>Y x B = { (y, b) }</strong> where <strong>y ∈ Y, b ∈ B</strong> (<strong>∈</strong> means &quot;is an element of&quot;).</p>
<p>The real challenge is defining what a pair means in terms of sets. </p>
<p><img src="pair.svg" alt="A pair"></p>
<p>Note that the pair have to be <em>ordered</em>, so it cannot be just a set of two elements (formally speaking <strong>A x B ≠ B x A for all A and B </strong>). Some mathematical operations such as addition and multiplication don&#39;t care about order, but others, such as subtraction, do. And in programming we have the ability to assign names to each member of an object, which accomplishes the same purpose as the ordering does in pairs.</p>
<p>So the pair must be ordered, and sets aren&#39;t. Turns out that that hasn&#39;t stopped mathematicians from coming up with multiple ingenious ways to represent an ordered pair using sets. Here is the first one, which was discovered by Norbert Wiener in 1914. The definition is notable for its smart use of the uniqueness of the empty set. </p>
<p><img src="pair_as_set_2.svg" alt="A pair, represented by sets"></p>
<p>The next one was discovered in the same year by Felix Hausdorff. In order to use that one, we just have to define &quot;1&quot;, and &quot;2&quot; first.</p>
<p><img src="pair_as_set_3.svg" alt="A pair, represented by sets"></p>
<p>Discovered in 1921 Kazimierz Kuratowski, this one uses just the component of the pair.</p>
<p><img src="pair_as_set_1.svg" alt="A pair, represented by sets"></p>
<h2 id="defining-products-in-terms-of-functions-">Defining products in Terms of Functions </h2>
<p>In the previous chapter we provided a definition of a product by <em>zooming in</em> the individual elements of the sets and seeing what they are made of. This gave us a <em>low-level</em> view of products. This time we will try to do the opposite, and be as oblivious to the contents of our sets as possible. Instead of zooming in we will zoom out, and try define the product in terms of functions and functional composition. Effectively we will be working at a higher level of abstraction.</p>
<p>So let&#39;s begin with an external diagram, showing the definition of the product. Disclaimer: I know that this is a somewhat weird notation, but don&#39;t worry, we will not be using it for very long.</p>
<p><img src="product_external.svg" alt="Product, external diagram"></p>
<p>This diagram already contains the first piece of the puzzle - if the product of sets <strong>Y</strong> and <strong>B</strong>, is a set <strong>G</strong>, there has to be one function <strong>G → Y</strong> and one function <strong>G → B</strong> which give back the elements. We can use this as part of our definition.</p>
<p>However, the product of <strong>G</strong> and <strong>B</strong> is not the only set for which such functions can be defined. For example a set of triples of <strong>Y x B x R</strong> for some random element <strong>R</strong> also does. If there is a function from <strong>G</strong> to <strong>B</strong> then the set <strong>G</strong> itself meets our condition for being the product, because it is connected to <strong>B</strong> and to itself. And depending on our specific case there can be many other other such objects.</p>
<p><img src="product_candidates.svg" alt="Product, external diagram"></p>
<p>So how can we set apart these &quot;imposter&quot; products from the &quot;true&quot; product without looking at their contents? Simple, for each of them, there exists a function that converts it to the one true product. Why? In order for a set <strong>I</strong> to serve as an impostor for the product of <strong>B</strong> and <strong>Y</strong> there should be a functions from it, to the two elements of the pair (so <strong>I → B</strong> and <strong>I → Y</strong>). But if we have functions from the impostor to both members of a product, then we should also be able to define a function from it to the product itself. In other words, if we have <strong>I → B</strong> and <strong>I → Y</strong> we should also have <strong>I → B x Y </strong>. This is true because the product is by definition nothing more and nothing less than the sum of its parts.</p>
<p>And thus we have found our definition: If <strong>B</strong> and <strong>Y</strong> are sets, then their product <strong>B x Y</strong> is a set such that for all sets <strong>I</strong> for which functions <strong>I → Y</strong> and <strong>I → B</strong> exist, there also exists a function <strong>I → B x Y</strong>, such that this diagram commutes.</p>
<p><img src="products_morphisms.svg" alt="Product, external diagram"></p>
<p>Again, notice that the definition does not make any references to the set&#39;s elements.</p>
<p>Task: Convert the definition so it&#39;s not about sets, and products, but about types and programming structures.</p>
<h1 id="sum">Sum</h1>
<p>We will now study a construct that is pretty similar to the product, but at the same time it is very different. Similar because, like the product, it is a relation between two sets which allows you to unite them into one, without erasing their structure. Different because the the product encodes an <strong>AND</strong> relation, while the sum encodes an <strong>OR</strong> relation.</p>
<p><img src="coproduct.svg" alt="Sum or coproduct"></p>
<p>For example, a parent is either a mother of a father of a child, so the set of parent&#39;s is a sum set of the set of mothers and fathers. In this case the two sets have no common elements.</p>
<h2 id="defining-sums-in-therms-of-sets">Defining Sums in Therms of sets</h2>
<p>Simply put, a sum of two sets is a set that contains all elements from the first set and all elements from the second one. But, again like with the product, there is a little twist - just like the elements of the product aren&#39;t just two-element sets, the elements of the sum are not just copies of the elements of the sets which consist of it. If that were the case, then part of the structure would be lost.</p>
<p>Notice the circles that encompass all elements of the sum set. If an element is a member of both sets that the sum consists of, it should be there two times - once because it is a member of the first set and once because it is a member of the second one. But a set cannot contain two instances of the same element, and that is why all elements in the sum are <em>wrapped</em> this way.</p>
<p>If we have to compare the sum or the product, we can say that:</p>
<p>The <em>product</em> of two sets is related to an element of the first one <em>and</em> one element of the second one.<br> A <em>sum</em> of two sets is related to an element of the first one <em>or</em>  one element of the second one.</p>
